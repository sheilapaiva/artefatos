# -*- coding: utf-8 -*-
"""redes_neurais_recorrentes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g43mIh-jcjwhn_s5n7i37ZzJ8M53WN9x
"""

import tensorflow as tf
import pandas as pd
import numpy as np
import math
import time
from sklearn.metrics import mean_absolute_error, mean_squared_error, mean_squared_log_error,median_absolute_error,r2_score
from datetime import datetime

from keras.models import Sequential
from keras.layers import Dense,LSTM
from sklearn.preprocessing import MinMaxScaler

def prediction_rnn(df, metrics, epochs):
 
  #normalize
  df.timestamp = list(range(df.shape[0]))
  df['timestamp'] = df['timestamp'].apply(lambda x: datetime.fromtimestamp(x))

  df.dropna(inplace=True)

  #extract only the closing data
  data = df.filter([metrics])
  dataset = data.values
  
  #separates 80% of this data
  training_data_len = math.floor(len(dataset)*.8)

  #scaling to the range between 0 and 1
  scaler = MinMaxScaler(feature_range=(0,1))
  scaled_data = scaler.fit_transform(dataset)

  #creating a training dataset
  train_data = scaled_data[0:training_data_len,:]
  
  #separating training and testing data
  x_train=[]
  y_train=[]

  for i in range(60,len(train_data)):
    x_train.append(train_data[i-60:i,0])
    y_train.append(train_data[i,0])

  #converting x_train and y_train to a numpy array
  x_train,y_train = np.array(x_train), np.array(y_train)

  #data resizing
  x_train=np.reshape(x_train, (x_train.shape[0], x_train.shape[1],1))

  #creating the test base
  test_data=scaled_data[training_data_len-60:,:]

  #creating x_test and y_test
  x_test=[]
  y_test=dataset[training_data_len:,:]

  for i in range(60,len(test_data)):
    x_test.append(test_data[i-60:i,0])

  x_test=np.array(x_test)
  x_test=np.reshape(x_test, (x_test.shape[0],x_test.shape[1],1))

  #creating the model
  model = Sequential()
  model.add(LSTM(50, return_sequences=True, input_shape=(x_train.shape[1],1)))
  model.add(LSTM(50, return_sequences=True))
  model.add(LSTM(50, return_sequences=False))
  model.add(Dense(25))
  model.add(Dense(1))

  #compiling the model
  model.compile(optimizer='adam', loss='mse')

  #training the model
  model.fit(x_train, y_train, batch_size=100,epochs=epochs, validation_data=(x_test, y_test))

  #generating the forecasts
  predictions = model.predict(x_test)
 
  #reversing the scale
  predictions = scaler.inverse_transform(predictions)

  return predictions, y_test